\section{The algorithm}
This section will go through the Efficient Graph-Based Image Segmentation
algorithm introduced by Pedro F. Felzenswalb and Daniel P. Huttenlocher \cite{felzenszwalb2004}.
To help the explanation throughout the chapter four images will be used, that is figure \ref{fig:smile-rgb},
\ref{fig:smile-red}, \ref{fig:smile-green} and \ref{fig:smile-blue}.

The algorithm is constructed in a general fashion which makes it possible to use
under many different settings. The key parts needed are an undirected graph and
some weight on each edge in the graph. As an example to this figure \ref{fig:smile-red}
can help, the red channel from the "smile" image. The image is 10x10 pixels is
size and construction of the undirected weighted graph is done by comparing
neighbouring pixels with each other. All pixels except the ones around the border
are connected to 8 neighbours (right,left,up,down and all four corners).
In other words the connectivity is chosen to be 8. Other types of connectevity
is 4-adjacency or mixed adjacency.

% TODO: Short example with image about connectivity?

When building the graph each edge get a weight that is the difference between
intensity in connected pixels. Pixel \(I(0,0)\) is mostly black so a good estimate
is that it has an intensity level of 10. The neighbour to the right \(I(0,1)\) has
the same intensity but the two neighbours downwards \(I(1,0)\) and \(I(1,1)\) are
white. An estimate for the white color is 250 in intensity. The edge weight is
now calculated to 0 between the two black pixels and 240 between the black and the
two white pixels.

\begin{figure}[ht]
    \begin{minipage}[t]{0.45\linewidth}
        \centering
        \includegraphics[width=\textwidth]{images/smile/smile-original.jpg}
        \caption{Smile, RGB color image}
        \label{fig:smile-rgb}
    \end{minipage}
    \hspace{0.5cm}
    \begin{minipage}[t]{0.45\linewidth}
        \centering
        \includegraphics[width=\textwidth]{images/smile/smile-red-channel.jpg}
        \caption{Smile, red channel.}
        \label{fig:smile-red}
    \end{minipage}
\end{figure}
\begin{figure}[ht]
    \begin{minipage}[t]{0.45\linewidth}
        \centering
        \includegraphics[width=\textwidth]{images/smile/smile-green-channel.jpg}
        \caption{Smile, green channel.}
        \label{fig:smile-green}
    \end{minipage}
    \hspace{0.5cm}
    \begin{minipage}[t]{0.45\linewidth}
        \centering
        \includegraphics[width=\textwidth]{images/smile/smile-blue-channel.jpg}
        \caption{Smile, blue channel.}
        \label{fig:smile-blue}
    \end{minipage}
\end{figure}

With the undirected weighted graph built it's time to take a closer look at the
segmentation. The goal with the algorithm is to be fast and {\em "Capture perceptually
important groupings or regions, which often reflect global aspects of the image"} \cite{felzenszwalb2004}.
One easy way to segment an image is to say that all edges that are less than some
constant \(k\) should belong to the same region. So in the example image, figure \ref{fig:smile-red},
it would work pretty well as all the regions that are visually considered to belong
together would be grouped together. The problem arises as soon as this is tried
on a "real" image that has not been created on a computer. Remember the discussion
about noise from earlier chapter. Noise in just one pixel, e.g. the center
pixel in one of the eyes could cause the algorithm (with constant \(k\)) to divide
the eye into 5 different regions.

Instead of a constant that decides whether a pixel should belong to a region or
not Felzenswalb and Huttenlocher have come up with a predicate that is variable
and takes the neighbouring regions into account. To continue explaining the
algorithm some terminology and a more mathematical approach is needed. The following
paragraphs are the key parts from the original paper \cite[ch. 3.1 Pairwise
Region Comparison Predicate]{felzenszwalb2004}.

The goal is to decide whether there should be a boundary between two pixels or
two pixels should belong to the same component. A component is a connected region of one
or more pixels. Let \(D\) be the predicate that is true if there should be a
boundary or false if the two pixels should belong to the same component. Before
defining \(D\) two other definitions are needed. First of all the definition
of {\em internal difference}.

\begin{equation}
    \label{eq:internalDifference}
    \text{Int}(C) = \underset{e \in \text{MST}(C,E)}{\text{max}} w(e)
\end{equation}

% The basic idea with the algorithm is to create an undirected graph of all the
% pixels in the image that you want to find regions within. Each pixel is
% connected to all its neighbours with a certain weight. The algorithm first
% sorts all the weights for all edges in a non-decreasing order. The next step
% is to start building a minimum spanning forest with all the edges between pixels
% in the image/graph. For each iteration in the algorithm another edge is selected
% (the one with the lowest weight that has not already been selected) and it's considered
% if the two pixels it connects should belong to the same region. The decision is made
% depending on what is called internal difference in comparison to the weight of
% the selected edge.
%
% Let's take an example with figure \ref{fig:smile-red}, the smile red channel,
% the image is squared 10x10 pixels. The first step is to build a graph of all
% the pixels the intensity of each pixel will be used to define the edge weight.
% All edges which has the same color in both regions will get an edge weight of
% zero and all other edges will be more than zero. As an example if the top left
% pixel is chosen it's close to black, approximately 0 in intensity. As it is the
% top most left pixel it only has three neighbours, the one to the right, down and
% corner connection right-downwards on the diagonal. The pixel to the right has
% the same intensity value so the edge weight is 0. The other two neighbours are
% white which means an intensity of around 255. The difference between zero and
% 255 is 255 so the edge weights will be 255 here. This procedure continues on
% until all edges has a weight and the undirected graph is completely built.
%
% The algorithm now continues to select the edge with the lowest weight and compares
% its value with the internal difference of respective region it connects. So to get
% back to our top left most pixel. The edge to the right has the weight of 0 so
% the algorithm starts with that one. As this is the first edge selected respective
% pixel doesn't have any internal difference...


% TODO: Add basics about Kruskal's minimum spanning tree.

% TODO: Add detailed gaussion description in digital image processing and
% then describe the difference here what it means to increase sigma value.

% TODO: Show an simple color image that has some differences when it
% comes to 4 or 8 connectness.

% \subsection{Building the graph}
% \subsection{Threshold function}
% What about taking into account width and breadth but crossings wouldn't
% count and curved roads would not be found.
\subsection{}
TODO
